# coding: utf-8

"""
    STACKIT Observability API

    API endpoints for Observability on STACKIT

    The version of the OpenAPI document: 1.1.1
    Contact: stackit-argus@mail.schwarz
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501 docstring might be too long

from __future__ import annotations

import json
import pprint
from typing import Any, ClassVar, Dict, List, Optional, Set

from pydantic import BaseModel, ConfigDict, Field
from typing_extensions import Annotated, Self


class UpdateAlertConfigsPayloadGlobal(BaseModel):
    """
    Global config. If nothing passed the default argus config will be used.
    """

    opsgenie_api_key: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = Field(
        default=None,
        description="Opsgenie api key `Additional Validators:` * should only include the characters: a-zA-Z0-9-",
        alias="opsgenieApiKey",
    )
    opsgenie_api_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = Field(
        default=None,
        description="Opsgenie api url `Additional Validators:` * must be a syntactically valid url address",
        alias="opsgenieApiUrl",
    )
    resolve_timeout: Optional[Annotated[str, Field(min_length=2, strict=True, max_length=8)]] = Field(
        default="5m",
        description="ResolveTimeout is the default value used by alertmanager if the alert does not include EndsAt, after this time passes it can declare the alert as resolved if it has not been updated. This has no impact on alerts from Prometheus, as they always include EndsAt.  `Additional Validators:` * must be a valid time format",
        alias="resolveTimeout",
    )
    smtp_auth_identity: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = Field(
        default=None,
        description="Auth identity. `Additional Validators:` * must be a syntactically valid email address",
        alias="smtpAuthIdentity",
    )
    smtp_auth_password: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = Field(
        default=None, description="SMTP Auth using LOGIN and PLAIN.", alias="smtpAuthPassword"
    )
    smtp_auth_username: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = Field(
        default=None,
        description="SMTP Auth using CRAM-MD5, LOGIN and PLAIN. If empty, Alertmanager doesn't authenticate to the SMTP server.",
        alias="smtpAuthUsername",
    )
    smtp_from: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = Field(
        default=None,
        description="The default SMTP From header field.  `Additional Validators:` * must be a syntactically valid email address",
        alias="smtpFrom",
    )
    smtp_smarthost: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=200)]] = Field(
        default=None,
        description="The default SMTP smarthost used for sending emails, including port number. Port number usually is 25, or 587 for SMTP over TLS (sometimes referred to as STARTTLS). Example: smtp.example.org:587  `Additional Validators:` * should only include the characters: a-zA-Z0-9_./@&?:-",
        alias="smtpSmarthost",
    )
    __properties: ClassVar[List[str]] = [
        "opsgenieApiKey",
        "opsgenieApiUrl",
        "resolveTimeout",
        "smtpAuthIdentity",
        "smtpAuthPassword",
        "smtpAuthUsername",
        "smtpFrom",
        "smtpSmarthost",
    ]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UpdateAlertConfigsPayloadGlobal from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UpdateAlertConfigsPayloadGlobal from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "opsgenieApiKey": obj.get("opsgenieApiKey"),
                "opsgenieApiUrl": obj.get("opsgenieApiUrl"),
                "resolveTimeout": obj.get("resolveTimeout") if obj.get("resolveTimeout") is not None else "5m",
                "smtpAuthIdentity": obj.get("smtpAuthIdentity"),
                "smtpAuthPassword": obj.get("smtpAuthPassword"),
                "smtpAuthUsername": obj.get("smtpAuthUsername"),
                "smtpFrom": obj.get("smtpFrom"),
                "smtpSmarthost": obj.get("smtpSmarthost"),
            }
        )
        return _obj
