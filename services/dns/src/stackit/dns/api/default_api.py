# coding: utf-8

"""
    STACKIT DNS API

    This api provides dns

    The version of the OpenAPI document: 1.0
    Contact: stackit-dns@mail.schwarz
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501 docstring might be too long

from typing import Any, Dict, List, Optional, Tuple, Union

from pydantic import (
    Field,
    StrictBool,
    StrictFloat,
    StrictInt,
    StrictStr,
    validate_call,
)
from stackit.core.configuration import Configuration
from typing_extensions import Annotated

from stackit.dns.api_client import ApiClient, RequestSerialized
from stackit.dns.api_response import ApiResponse
from stackit.dns.models.clone_zone_payload import CloneZonePayload
from stackit.dns.models.create_label_payload import CreateLabelPayload
from stackit.dns.models.create_label_response import CreateLabelResponse
from stackit.dns.models.create_record_set_payload import CreateRecordSetPayload
from stackit.dns.models.create_zone_payload import CreateZonePayload
from stackit.dns.models.delete_label_response import DeleteLabelResponse
from stackit.dns.models.export_record_sets_payload import ExportRecordSetsPayload
from stackit.dns.models.import_record_sets_payload import ImportRecordSetsPayload
from stackit.dns.models.import_record_sets_response import ImportRecordSetsResponse
from stackit.dns.models.list_labels_response import ListLabelsResponse
from stackit.dns.models.list_record_sets_response import ListRecordSetsResponse
from stackit.dns.models.list_zones_response import ListZonesResponse
from stackit.dns.models.message import Message
from stackit.dns.models.move_code_response import MoveCodeResponse
from stackit.dns.models.move_zone_payload import MoveZonePayload
from stackit.dns.models.partial_update_record_payload import PartialUpdateRecordPayload
from stackit.dns.models.partial_update_record_set_payload import (
    PartialUpdateRecordSetPayload,
)
from stackit.dns.models.partial_update_zone_payload import PartialUpdateZonePayload
from stackit.dns.models.record_set_response import RecordSetResponse
from stackit.dns.models.validate_move_code_payload import ValidateMoveCodePayload
from stackit.dns.models.zone_data_exchange import ZoneDataExchange
from stackit.dns.models.zone_response import ZoneResponse
from stackit.dns.rest import RESTResponseType


class DefaultApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, configuration: Configuration = None) -> None:
        if configuration is None:
            configuration = Configuration()
        self.configuration = configuration
        self.api_client = ApiClient(self.configuration)

    @validate_call
    def clone_zone(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        clone_zone_payload: Annotated[CloneZonePayload, Field(description="zone to clone")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ZoneResponse:
        """Clone an existing zone with all record sets to a new zone with a different name

        Clone an existing zone with all record sets to a new zone with a different name

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param clone_zone_payload: zone to clone (required)
        :type clone_zone_payload: CloneZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._clone_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            clone_zone_payload=clone_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ZoneResponse",
            "400": "Message",
            "404": "Message",
            "409": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def clone_zone_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        clone_zone_payload: Annotated[CloneZonePayload, Field(description="zone to clone")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ZoneResponse]:
        """Clone an existing zone with all record sets to a new zone with a different name

        Clone an existing zone with all record sets to a new zone with a different name

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param clone_zone_payload: zone to clone (required)
        :type clone_zone_payload: CloneZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._clone_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            clone_zone_payload=clone_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ZoneResponse",
            "400": "Message",
            "404": "Message",
            "409": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def clone_zone_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        clone_zone_payload: Annotated[CloneZonePayload, Field(description="zone to clone")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Clone an existing zone with all record sets to a new zone with a different name

        Clone an existing zone with all record sets to a new zone with a different name

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param clone_zone_payload: zone to clone (required)
        :type clone_zone_payload: CloneZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._clone_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            clone_zone_payload=clone_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ZoneResponse",
            "400": "Message",
            "404": "Message",
            "409": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _clone_zone_serialize(
        self,
        project_id,
        zone_id,
        clone_zone_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if clone_zone_payload is not None:
            _body_params = clone_zone_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/clone",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def create_label(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        create_label_payload: Annotated[CreateLabelPayload, Field(description="record set to create")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CreateLabelResponse:
        """Create or update label

        Create or update label

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param create_label_payload: record set to create (required)
        :type create_label_payload: CreateLabelPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_label_serialize(
            project_id=project_id,
            zone_id=zone_id,
            create_label_payload=create_label_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "CreateLabelResponse",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_label_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        create_label_payload: Annotated[CreateLabelPayload, Field(description="record set to create")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CreateLabelResponse]:
        """Create or update label

        Create or update label

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param create_label_payload: record set to create (required)
        :type create_label_payload: CreateLabelPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_label_serialize(
            project_id=project_id,
            zone_id=zone_id,
            create_label_payload=create_label_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "CreateLabelResponse",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_label_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        create_label_payload: Annotated[CreateLabelPayload, Field(description="record set to create")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or update label

        Create or update label

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param create_label_payload: record set to create (required)
        :type create_label_payload: CreateLabelPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_label_serialize(
            project_id=project_id,
            zone_id=zone_id,
            create_label_payload=create_label_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "CreateLabelResponse",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _create_label_serialize(
        self,
        project_id,
        zone_id,
        create_label_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_label_payload is not None:
            _body_params = create_label_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PUT",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/labels",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def create_move_code(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MoveCodeResponse:
        """request a move code to move zone to another project

        move zone from one project to another

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_move_code_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "MoveCodeResponse",
            "400": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_move_code_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MoveCodeResponse]:
        """request a move code to move zone to another project

        move zone from one project to another

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_move_code_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "MoveCodeResponse",
            "400": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_move_code_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """request a move code to move zone to another project

        move zone from one project to another

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_move_code_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "MoveCodeResponse",
            "400": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _create_move_code_serialize(
        self,
        project_id,
        zone_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/move-code",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def create_record_set(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        create_record_set_payload: Annotated[CreateRecordSetPayload, Field(description="record set to create")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RecordSetResponse:
        """Post record set

        Post record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param create_record_set_payload: record set to create (required)
        :type create_record_set_payload: CreateRecordSetPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            create_record_set_payload=create_record_set_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "RecordSetResponse",
            "400": "Message",
            "404": "Message",
            "409": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_record_set_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        create_record_set_payload: Annotated[CreateRecordSetPayload, Field(description="record set to create")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RecordSetResponse]:
        """Post record set

        Post record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param create_record_set_payload: record set to create (required)
        :type create_record_set_payload: CreateRecordSetPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            create_record_set_payload=create_record_set_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "RecordSetResponse",
            "400": "Message",
            "404": "Message",
            "409": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_record_set_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        create_record_set_payload: Annotated[CreateRecordSetPayload, Field(description="record set to create")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Post record set

        Post record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param create_record_set_payload: record set to create (required)
        :type create_record_set_payload: CreateRecordSetPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            create_record_set_payload=create_record_set_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "RecordSetResponse",
            "400": "Message",
            "404": "Message",
            "409": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _create_record_set_serialize(
        self,
        project_id,
        zone_id,
        create_record_set_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_record_set_payload is not None:
            _body_params = create_record_set_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/rrsets",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def create_zone(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        create_zone_payload: Annotated[CreateZonePayload, Field(description="zone to create")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ZoneResponse:
        """Post create a new zone

        Post zone create a new zone

        :param project_id: project id (required)
        :type project_id: str
        :param create_zone_payload: zone to create (required)
        :type create_zone_payload: CreateZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_zone_serialize(
            project_id=project_id,
            create_zone_payload=create_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ZoneResponse",
            "400": "Message",
            "404": "Message",
            "409": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def create_zone_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        create_zone_payload: Annotated[CreateZonePayload, Field(description="zone to create")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ZoneResponse]:
        """Post create a new zone

        Post zone create a new zone

        :param project_id: project id (required)
        :type project_id: str
        :param create_zone_payload: zone to create (required)
        :type create_zone_payload: CreateZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_zone_serialize(
            project_id=project_id,
            create_zone_payload=create_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ZoneResponse",
            "400": "Message",
            "404": "Message",
            "409": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def create_zone_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        create_zone_payload: Annotated[CreateZonePayload, Field(description="zone to create")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Post create a new zone

        Post zone create a new zone

        :param project_id: project id (required)
        :type project_id: str
        :param create_zone_payload: zone to create (required)
        :type create_zone_payload: CreateZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._create_zone_serialize(
            project_id=project_id,
            create_zone_payload=create_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ZoneResponse",
            "400": "Message",
            "404": "Message",
            "409": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _create_zone_serialize(
        self,
        project_id,
        create_zone_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if create_zone_payload is not None:
            _body_params = create_zone_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def delete_label(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        key: Annotated[StrictStr, Field(description="key of the label")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DeleteLabelResponse:
        """Delete a label

        Delete a label

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param key: key of the label (required)
        :type key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_label_serialize(
            project_id=project_id,
            zone_id=zone_id,
            key=key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "DeleteLabelResponse",
            "403": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_label_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        key: Annotated[StrictStr, Field(description="key of the label")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DeleteLabelResponse]:
        """Delete a label

        Delete a label

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param key: key of the label (required)
        :type key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_label_serialize(
            project_id=project_id,
            zone_id=zone_id,
            key=key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "DeleteLabelResponse",
            "403": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_label_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        key: Annotated[StrictStr, Field(description="key of the label")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a label

        Delete a label

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param key: key of the label (required)
        :type key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_label_serialize(
            project_id=project_id,
            zone_id=zone_id,
            key=key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "DeleteLabelResponse",
            "403": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _delete_label_serialize(
        self,
        project_id,
        zone_id,
        key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        if key is not None:
            _path_params["key"] = key
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/labels/{key}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def delete_move_code(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """delete/invalidate a move code

        delete/invalidate a move code

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_move_code_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_move_code_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """delete/invalidate a move code

        delete/invalidate a move code

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_move_code_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_move_code_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """delete/invalidate a move code

        delete/invalidate a move code

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_move_code_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _delete_move_code_serialize(
        self,
        project_id,
        zone_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/move-code",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def delete_record_set(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Delete a record set

        Delete a record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_record_set_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Delete a record set

        Delete a record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_record_set_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a record set

        Delete a record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _delete_record_set_serialize(
        self,
        project_id,
        zone_id,
        rr_set_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        if rr_set_id is not None:
            _path_params["rrSetId"] = rr_set_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def delete_zone(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Delete a zone

        Delete a zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def delete_zone_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Delete a zone

        Delete a zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def delete_zone_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete a zone

        Delete a zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._delete_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _delete_zone_serialize(
        self,
        project_id,
        zone_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="DELETE",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def export_record_sets(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        export_record_sets_payload: Annotated[ExportRecordSetsPayload, Field(description="export configuration")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ZoneDataExchange:
        """Export all records in a single zone

        Export Zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param export_record_sets_payload: export configuration (required)
        :type export_record_sets_payload: ExportRecordSetsPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._export_record_sets_serialize(
            project_id=project_id,
            zone_id=zone_id,
            export_record_sets_payload=export_record_sets_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "ZoneDataExchange",
            "400": "ErrorMessage",
            "403": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def export_record_sets_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        export_record_sets_payload: Annotated[ExportRecordSetsPayload, Field(description="export configuration")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ZoneDataExchange]:
        """Export all records in a single zone

        Export Zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param export_record_sets_payload: export configuration (required)
        :type export_record_sets_payload: ExportRecordSetsPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._export_record_sets_serialize(
            project_id=project_id,
            zone_id=zone_id,
            export_record_sets_payload=export_record_sets_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "ZoneDataExchange",
            "400": "ErrorMessage",
            "403": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def export_record_sets_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        export_record_sets_payload: Annotated[ExportRecordSetsPayload, Field(description="export configuration")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Export all records in a single zone

        Export Zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param export_record_sets_payload: export configuration (required)
        :type export_record_sets_payload: ExportRecordSetsPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._export_record_sets_serialize(
            project_id=project_id,
            zone_id=zone_id,
            export_record_sets_payload=export_record_sets_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "201": "ZoneDataExchange",
            "400": "ErrorMessage",
            "403": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _export_record_sets_serialize(
        self,
        project_id,
        zone_id,
        export_record_sets_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if export_record_sets_payload is not None:
            _body_params = export_record_sets_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                ["application/json", "text/csv", "text/plain"]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/export",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_record_set(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RecordSetResponse:
        """Get a single rrset

        Get rrset

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._get_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "RecordSetResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_record_set_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RecordSetResponse]:
        """Get a single rrset

        Get rrset

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._get_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "RecordSetResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_record_set_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a single rrset

        Get rrset

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._get_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "RecordSetResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _get_record_set_serialize(
        self,
        project_id,
        zone_id,
        rr_set_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        if rr_set_id is not None:
            _path_params["rrSetId"] = rr_set_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def get_zone(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ZoneResponse:
        """Get a single zone

        Get zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._get_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ZoneResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def get_zone_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ZoneResponse]:
        """Get a single zone

        Get zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._get_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ZoneResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def get_zone_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a single zone

        Get zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._get_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ZoneResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _get_zone_serialize(
        self,
        project_id,
        zone_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def import_record_sets(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        import_record_sets_payload: Annotated[
            ImportRecordSetsPayload, Field(description="accepts all response bodies for the export endpoint")
        ],
        format: Annotated[Optional[StrictStr], Field(description="format of the data to import")] = None,
        import_type: Annotated[Optional[StrictStr], Field(description="type of the zone import")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ImportRecordSetsResponse:
        """Imports a zone

        Imports a zone and overwrites/deletes/inserts all desired records

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param import_record_sets_payload: accepts all response bodies for the export endpoint (required)
        :type import_record_sets_payload: ImportRecordSetsPayload
        :param format: format of the data to import
        :type format: str
        :param import_type: type of the zone import
        :type import_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._import_record_sets_serialize(
            project_id=project_id,
            zone_id=zone_id,
            import_record_sets_payload=import_record_sets_payload,
            format=format,
            import_type=import_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ImportRecordSetsResponse",
            "400": "ErrorMessage",
            "403": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def import_record_sets_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        import_record_sets_payload: Annotated[
            ImportRecordSetsPayload, Field(description="accepts all response bodies for the export endpoint")
        ],
        format: Annotated[Optional[StrictStr], Field(description="format of the data to import")] = None,
        import_type: Annotated[Optional[StrictStr], Field(description="type of the zone import")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ImportRecordSetsResponse]:
        """Imports a zone

        Imports a zone and overwrites/deletes/inserts all desired records

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param import_record_sets_payload: accepts all response bodies for the export endpoint (required)
        :type import_record_sets_payload: ImportRecordSetsPayload
        :param format: format of the data to import
        :type format: str
        :param import_type: type of the zone import
        :type import_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._import_record_sets_serialize(
            project_id=project_id,
            zone_id=zone_id,
            import_record_sets_payload=import_record_sets_payload,
            format=format,
            import_type=import_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ImportRecordSetsResponse",
            "400": "ErrorMessage",
            "403": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def import_record_sets_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        import_record_sets_payload: Annotated[
            ImportRecordSetsPayload, Field(description="accepts all response bodies for the export endpoint")
        ],
        format: Annotated[Optional[StrictStr], Field(description="format of the data to import")] = None,
        import_type: Annotated[Optional[StrictStr], Field(description="type of the zone import")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Imports a zone

        Imports a zone and overwrites/deletes/inserts all desired records

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param import_record_sets_payload: accepts all response bodies for the export endpoint (required)
        :type import_record_sets_payload: ImportRecordSetsPayload
        :param format: format of the data to import
        :type format: str
        :param import_type: type of the zone import
        :type import_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._import_record_sets_serialize(
            project_id=project_id,
            zone_id=zone_id,
            import_record_sets_payload=import_record_sets_payload,
            format=format,
            import_type=import_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ImportRecordSetsResponse",
            "400": "ErrorMessage",
            "403": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _import_record_sets_serialize(
        self,
        project_id,
        zone_id,
        import_record_sets_payload,
        format,
        import_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        if format is not None:

            _query_params.append(("format", format))

        if import_type is not None:

            _query_params.append(("importType", import_type))

        # process the header parameters
        # process the form parameters
        # process the body parameter
        if import_record_sets_payload is not None:
            _body_params = import_record_sets_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(
                ["application/json", "text/csv", "text/plain"]
            )
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/import",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def list_labels(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListLabelsResponse:
        """Get all labels

        All Labels

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._list_labels_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListLabelsResponse",
            "403": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_labels_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListLabelsResponse]:
        """Get all labels

        All Labels

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._list_labels_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListLabelsResponse",
            "403": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_labels_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get all labels

        All Labels

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._list_labels_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListLabelsResponse",
            "403": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _list_labels_serialize(
        self,
        project_id,
        zone_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/labels",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def list_record_sets(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="page")] = None,
        page_size: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="page size")
        ] = None,
        name_eq: Annotated[Optional[StrictStr], Field(description="filter name equal")] = None,
        name_like: Annotated[Optional[StrictStr], Field(description="filter name like")] = None,
        type_eq: Annotated[Optional[StrictStr], Field(description="filter type")] = None,
        state_eq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        state_neq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        active_eq: Annotated[Optional[StrictBool], Field(description="filter active equal")] = None,
        creation_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater with utc timestamp")
        ] = None,
        creation_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser with utc timestamp")
        ] = None,
        creation_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater equal with utc timestamp")
        ] = None,
        creation_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser equal with utc timestamp")
        ] = None,
        creation_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater with utc timestamp")
        ] = None,
        creation_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser with utc timestamp")
        ] = None,
        creation_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater equal with utc timestamp")
        ] = None,
        creation_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser equal with utc timestamp")
        ] = None,
        update_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter update started greater with utc timestamp")
        ] = None,
        update_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser with utc timestamp")
        ] = None,
        update_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter update started greater equal with utc timestamp")
        ] = None,
        update_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser equal with utc timestamp")
        ] = None,
        update_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater with utc timestamp")
        ] = None,
        update_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser with utc timestamp")
        ] = None,
        update_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater equal with utc timestamp")
        ] = None,
        update_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser equal with utc timestamp")
        ] = None,
        order_by_name: Annotated[Optional[StrictStr], Field(description="order by name")] = None,
        order_by_creation_started: Annotated[Optional[StrictStr], Field(description="order by creationStarted")] = None,
        order_by_creation_finished: Annotated[
            Optional[StrictStr], Field(description="order by creationFinished")
        ] = None,
        order_by_update_started: Annotated[Optional[StrictStr], Field(description="order by updateStarted")] = None,
        order_by_update_finished: Annotated[Optional[StrictStr], Field(description="order by updateFinished")] = None,
        order_by_type: Annotated[Optional[StrictStr], Field(description="order by type")] = None,
        order_by_state: Annotated[Optional[StrictStr], Field(description="order by state")] = None,
        order_by_record_count: Annotated[Optional[StrictStr], Field(description="order by record count")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListRecordSetsResponse:
        """All get selected RRSets

        All RRSet

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param page: page
        :type page: int
        :param page_size: page size
        :type page_size: int
        :param name_eq: filter name equal
        :type name_eq: str
        :param name_like: filter name like
        :type name_like: str
        :param type_eq: filter type
        :type type_eq: str
        :param state_eq: filter state
        :type state_eq: str
        :param state_neq: filter state
        :type state_neq: str
        :param active_eq: filter active equal
        :type active_eq: bool
        :param creation_started_gt: filter creation started greater with utc timestamp
        :type creation_started_gt: str
        :param creation_started_lt: filter creation started lesser with utc timestamp
        :type creation_started_lt: str
        :param creation_started_gte: filter creation started greater equal with utc timestamp
        :type creation_started_gte: str
        :param creation_started_lte: filter creation started lesser equal with utc timestamp
        :type creation_started_lte: str
        :param creation_finished_gt: filter creation finished greater with utc timestamp
        :type creation_finished_gt: str
        :param creation_finished_lt: filter creation finished lesser with utc timestamp
        :type creation_finished_lt: str
        :param creation_finished_gte: filter creation finished greater equal with utc timestamp
        :type creation_finished_gte: str
        :param creation_finished_lte: filter creation finished lesser equal with utc timestamp
        :type creation_finished_lte: str
        :param update_started_gt: filter update started greater with utc timestamp
        :type update_started_gt: str
        :param update_started_lt: filter update started lesser with utc timestamp
        :type update_started_lt: str
        :param update_started_gte: filter update started greater equal with utc timestamp
        :type update_started_gte: str
        :param update_started_lte: filter update started lesser equal with utc timestamp
        :type update_started_lte: str
        :param update_finished_gt: filter update finished greater with utc timestamp
        :type update_finished_gt: str
        :param update_finished_lt: filter update finished lesser with utc timestamp
        :type update_finished_lt: str
        :param update_finished_gte: filter update finished greater equal with utc timestamp
        :type update_finished_gte: str
        :param update_finished_lte: filter update finished lesser equal with utc timestamp
        :type update_finished_lte: str
        :param order_by_name: order by name
        :type order_by_name: str
        :param order_by_creation_started: order by creationStarted
        :type order_by_creation_started: str
        :param order_by_creation_finished: order by creationFinished
        :type order_by_creation_finished: str
        :param order_by_update_started: order by updateStarted
        :type order_by_update_started: str
        :param order_by_update_finished: order by updateFinished
        :type order_by_update_finished: str
        :param order_by_type: order by type
        :type order_by_type: str
        :param order_by_state: order by state
        :type order_by_state: str
        :param order_by_record_count: order by record count
        :type order_by_record_count: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._list_record_sets_serialize(
            project_id=project_id,
            zone_id=zone_id,
            page=page,
            page_size=page_size,
            name_eq=name_eq,
            name_like=name_like,
            type_eq=type_eq,
            state_eq=state_eq,
            state_neq=state_neq,
            active_eq=active_eq,
            creation_started_gt=creation_started_gt,
            creation_started_lt=creation_started_lt,
            creation_started_gte=creation_started_gte,
            creation_started_lte=creation_started_lte,
            creation_finished_gt=creation_finished_gt,
            creation_finished_lt=creation_finished_lt,
            creation_finished_gte=creation_finished_gte,
            creation_finished_lte=creation_finished_lte,
            update_started_gt=update_started_gt,
            update_started_lt=update_started_lt,
            update_started_gte=update_started_gte,
            update_started_lte=update_started_lte,
            update_finished_gt=update_finished_gt,
            update_finished_lt=update_finished_lt,
            update_finished_gte=update_finished_gte,
            update_finished_lte=update_finished_lte,
            order_by_name=order_by_name,
            order_by_creation_started=order_by_creation_started,
            order_by_creation_finished=order_by_creation_finished,
            order_by_update_started=order_by_update_started,
            order_by_update_finished=order_by_update_finished,
            order_by_type=order_by_type,
            order_by_state=order_by_state,
            order_by_record_count=order_by_record_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListRecordSetsResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_record_sets_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="page")] = None,
        page_size: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="page size")
        ] = None,
        name_eq: Annotated[Optional[StrictStr], Field(description="filter name equal")] = None,
        name_like: Annotated[Optional[StrictStr], Field(description="filter name like")] = None,
        type_eq: Annotated[Optional[StrictStr], Field(description="filter type")] = None,
        state_eq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        state_neq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        active_eq: Annotated[Optional[StrictBool], Field(description="filter active equal")] = None,
        creation_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater with utc timestamp")
        ] = None,
        creation_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser with utc timestamp")
        ] = None,
        creation_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater equal with utc timestamp")
        ] = None,
        creation_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser equal with utc timestamp")
        ] = None,
        creation_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater with utc timestamp")
        ] = None,
        creation_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser with utc timestamp")
        ] = None,
        creation_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater equal with utc timestamp")
        ] = None,
        creation_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser equal with utc timestamp")
        ] = None,
        update_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter update started greater with utc timestamp")
        ] = None,
        update_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser with utc timestamp")
        ] = None,
        update_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter update started greater equal with utc timestamp")
        ] = None,
        update_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser equal with utc timestamp")
        ] = None,
        update_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater with utc timestamp")
        ] = None,
        update_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser with utc timestamp")
        ] = None,
        update_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater equal with utc timestamp")
        ] = None,
        update_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser equal with utc timestamp")
        ] = None,
        order_by_name: Annotated[Optional[StrictStr], Field(description="order by name")] = None,
        order_by_creation_started: Annotated[Optional[StrictStr], Field(description="order by creationStarted")] = None,
        order_by_creation_finished: Annotated[
            Optional[StrictStr], Field(description="order by creationFinished")
        ] = None,
        order_by_update_started: Annotated[Optional[StrictStr], Field(description="order by updateStarted")] = None,
        order_by_update_finished: Annotated[Optional[StrictStr], Field(description="order by updateFinished")] = None,
        order_by_type: Annotated[Optional[StrictStr], Field(description="order by type")] = None,
        order_by_state: Annotated[Optional[StrictStr], Field(description="order by state")] = None,
        order_by_record_count: Annotated[Optional[StrictStr], Field(description="order by record count")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListRecordSetsResponse]:
        """All get selected RRSets

        All RRSet

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param page: page
        :type page: int
        :param page_size: page size
        :type page_size: int
        :param name_eq: filter name equal
        :type name_eq: str
        :param name_like: filter name like
        :type name_like: str
        :param type_eq: filter type
        :type type_eq: str
        :param state_eq: filter state
        :type state_eq: str
        :param state_neq: filter state
        :type state_neq: str
        :param active_eq: filter active equal
        :type active_eq: bool
        :param creation_started_gt: filter creation started greater with utc timestamp
        :type creation_started_gt: str
        :param creation_started_lt: filter creation started lesser with utc timestamp
        :type creation_started_lt: str
        :param creation_started_gte: filter creation started greater equal with utc timestamp
        :type creation_started_gte: str
        :param creation_started_lte: filter creation started lesser equal with utc timestamp
        :type creation_started_lte: str
        :param creation_finished_gt: filter creation finished greater with utc timestamp
        :type creation_finished_gt: str
        :param creation_finished_lt: filter creation finished lesser with utc timestamp
        :type creation_finished_lt: str
        :param creation_finished_gte: filter creation finished greater equal with utc timestamp
        :type creation_finished_gte: str
        :param creation_finished_lte: filter creation finished lesser equal with utc timestamp
        :type creation_finished_lte: str
        :param update_started_gt: filter update started greater with utc timestamp
        :type update_started_gt: str
        :param update_started_lt: filter update started lesser with utc timestamp
        :type update_started_lt: str
        :param update_started_gte: filter update started greater equal with utc timestamp
        :type update_started_gte: str
        :param update_started_lte: filter update started lesser equal with utc timestamp
        :type update_started_lte: str
        :param update_finished_gt: filter update finished greater with utc timestamp
        :type update_finished_gt: str
        :param update_finished_lt: filter update finished lesser with utc timestamp
        :type update_finished_lt: str
        :param update_finished_gte: filter update finished greater equal with utc timestamp
        :type update_finished_gte: str
        :param update_finished_lte: filter update finished lesser equal with utc timestamp
        :type update_finished_lte: str
        :param order_by_name: order by name
        :type order_by_name: str
        :param order_by_creation_started: order by creationStarted
        :type order_by_creation_started: str
        :param order_by_creation_finished: order by creationFinished
        :type order_by_creation_finished: str
        :param order_by_update_started: order by updateStarted
        :type order_by_update_started: str
        :param order_by_update_finished: order by updateFinished
        :type order_by_update_finished: str
        :param order_by_type: order by type
        :type order_by_type: str
        :param order_by_state: order by state
        :type order_by_state: str
        :param order_by_record_count: order by record count
        :type order_by_record_count: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._list_record_sets_serialize(
            project_id=project_id,
            zone_id=zone_id,
            page=page,
            page_size=page_size,
            name_eq=name_eq,
            name_like=name_like,
            type_eq=type_eq,
            state_eq=state_eq,
            state_neq=state_neq,
            active_eq=active_eq,
            creation_started_gt=creation_started_gt,
            creation_started_lt=creation_started_lt,
            creation_started_gte=creation_started_gte,
            creation_started_lte=creation_started_lte,
            creation_finished_gt=creation_finished_gt,
            creation_finished_lt=creation_finished_lt,
            creation_finished_gte=creation_finished_gte,
            creation_finished_lte=creation_finished_lte,
            update_started_gt=update_started_gt,
            update_started_lt=update_started_lt,
            update_started_gte=update_started_gte,
            update_started_lte=update_started_lte,
            update_finished_gt=update_finished_gt,
            update_finished_lt=update_finished_lt,
            update_finished_gte=update_finished_gte,
            update_finished_lte=update_finished_lte,
            order_by_name=order_by_name,
            order_by_creation_started=order_by_creation_started,
            order_by_creation_finished=order_by_creation_finished,
            order_by_update_started=order_by_update_started,
            order_by_update_finished=order_by_update_finished,
            order_by_type=order_by_type,
            order_by_state=order_by_state,
            order_by_record_count=order_by_record_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListRecordSetsResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_record_sets_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="page")] = None,
        page_size: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="page size")
        ] = None,
        name_eq: Annotated[Optional[StrictStr], Field(description="filter name equal")] = None,
        name_like: Annotated[Optional[StrictStr], Field(description="filter name like")] = None,
        type_eq: Annotated[Optional[StrictStr], Field(description="filter type")] = None,
        state_eq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        state_neq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        active_eq: Annotated[Optional[StrictBool], Field(description="filter active equal")] = None,
        creation_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater with utc timestamp")
        ] = None,
        creation_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser with utc timestamp")
        ] = None,
        creation_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater equal with utc timestamp")
        ] = None,
        creation_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser equal with utc timestamp")
        ] = None,
        creation_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater with utc timestamp")
        ] = None,
        creation_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser with utc timestamp")
        ] = None,
        creation_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater equal with utc timestamp")
        ] = None,
        creation_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser equal with utc timestamp")
        ] = None,
        update_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter update started greater with utc timestamp")
        ] = None,
        update_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser with utc timestamp")
        ] = None,
        update_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter update started greater equal with utc timestamp")
        ] = None,
        update_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser equal with utc timestamp")
        ] = None,
        update_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater with utc timestamp")
        ] = None,
        update_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser with utc timestamp")
        ] = None,
        update_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater equal with utc timestamp")
        ] = None,
        update_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser equal with utc timestamp")
        ] = None,
        order_by_name: Annotated[Optional[StrictStr], Field(description="order by name")] = None,
        order_by_creation_started: Annotated[Optional[StrictStr], Field(description="order by creationStarted")] = None,
        order_by_creation_finished: Annotated[
            Optional[StrictStr], Field(description="order by creationFinished")
        ] = None,
        order_by_update_started: Annotated[Optional[StrictStr], Field(description="order by updateStarted")] = None,
        order_by_update_finished: Annotated[Optional[StrictStr], Field(description="order by updateFinished")] = None,
        order_by_type: Annotated[Optional[StrictStr], Field(description="order by type")] = None,
        order_by_state: Annotated[Optional[StrictStr], Field(description="order by state")] = None,
        order_by_record_count: Annotated[Optional[StrictStr], Field(description="order by record count")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """All get selected RRSets

        All RRSet

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param page: page
        :type page: int
        :param page_size: page size
        :type page_size: int
        :param name_eq: filter name equal
        :type name_eq: str
        :param name_like: filter name like
        :type name_like: str
        :param type_eq: filter type
        :type type_eq: str
        :param state_eq: filter state
        :type state_eq: str
        :param state_neq: filter state
        :type state_neq: str
        :param active_eq: filter active equal
        :type active_eq: bool
        :param creation_started_gt: filter creation started greater with utc timestamp
        :type creation_started_gt: str
        :param creation_started_lt: filter creation started lesser with utc timestamp
        :type creation_started_lt: str
        :param creation_started_gte: filter creation started greater equal with utc timestamp
        :type creation_started_gte: str
        :param creation_started_lte: filter creation started lesser equal with utc timestamp
        :type creation_started_lte: str
        :param creation_finished_gt: filter creation finished greater with utc timestamp
        :type creation_finished_gt: str
        :param creation_finished_lt: filter creation finished lesser with utc timestamp
        :type creation_finished_lt: str
        :param creation_finished_gte: filter creation finished greater equal with utc timestamp
        :type creation_finished_gte: str
        :param creation_finished_lte: filter creation finished lesser equal with utc timestamp
        :type creation_finished_lte: str
        :param update_started_gt: filter update started greater with utc timestamp
        :type update_started_gt: str
        :param update_started_lt: filter update started lesser with utc timestamp
        :type update_started_lt: str
        :param update_started_gte: filter update started greater equal with utc timestamp
        :type update_started_gte: str
        :param update_started_lte: filter update started lesser equal with utc timestamp
        :type update_started_lte: str
        :param update_finished_gt: filter update finished greater with utc timestamp
        :type update_finished_gt: str
        :param update_finished_lt: filter update finished lesser with utc timestamp
        :type update_finished_lt: str
        :param update_finished_gte: filter update finished greater equal with utc timestamp
        :type update_finished_gte: str
        :param update_finished_lte: filter update finished lesser equal with utc timestamp
        :type update_finished_lte: str
        :param order_by_name: order by name
        :type order_by_name: str
        :param order_by_creation_started: order by creationStarted
        :type order_by_creation_started: str
        :param order_by_creation_finished: order by creationFinished
        :type order_by_creation_finished: str
        :param order_by_update_started: order by updateStarted
        :type order_by_update_started: str
        :param order_by_update_finished: order by updateFinished
        :type order_by_update_finished: str
        :param order_by_type: order by type
        :type order_by_type: str
        :param order_by_state: order by state
        :type order_by_state: str
        :param order_by_record_count: order by record count
        :type order_by_record_count: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._list_record_sets_serialize(
            project_id=project_id,
            zone_id=zone_id,
            page=page,
            page_size=page_size,
            name_eq=name_eq,
            name_like=name_like,
            type_eq=type_eq,
            state_eq=state_eq,
            state_neq=state_neq,
            active_eq=active_eq,
            creation_started_gt=creation_started_gt,
            creation_started_lt=creation_started_lt,
            creation_started_gte=creation_started_gte,
            creation_started_lte=creation_started_lte,
            creation_finished_gt=creation_finished_gt,
            creation_finished_lt=creation_finished_lt,
            creation_finished_gte=creation_finished_gte,
            creation_finished_lte=creation_finished_lte,
            update_started_gt=update_started_gt,
            update_started_lt=update_started_lt,
            update_started_gte=update_started_gte,
            update_started_lte=update_started_lte,
            update_finished_gt=update_finished_gt,
            update_finished_lt=update_finished_lt,
            update_finished_gte=update_finished_gte,
            update_finished_lte=update_finished_lte,
            order_by_name=order_by_name,
            order_by_creation_started=order_by_creation_started,
            order_by_creation_finished=order_by_creation_finished,
            order_by_update_started=order_by_update_started,
            order_by_update_finished=order_by_update_finished,
            order_by_type=order_by_type,
            order_by_state=order_by_state,
            order_by_record_count=order_by_record_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListRecordSetsResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _list_record_sets_serialize(
        self,
        project_id,
        zone_id,
        page,
        page_size,
        name_eq,
        name_like,
        type_eq,
        state_eq,
        state_neq,
        active_eq,
        creation_started_gt,
        creation_started_lt,
        creation_started_gte,
        creation_started_lte,
        creation_finished_gt,
        creation_finished_lt,
        creation_finished_gte,
        creation_finished_lte,
        update_started_gt,
        update_started_lt,
        update_started_gte,
        update_started_lte,
        update_finished_gt,
        update_finished_lt,
        update_finished_gte,
        update_finished_lte,
        order_by_name,
        order_by_creation_started,
        order_by_creation_finished,
        order_by_update_started,
        order_by_update_finished,
        order_by_type,
        order_by_state,
        order_by_record_count,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        if page is not None:

            _query_params.append(("page", page))

        if page_size is not None:

            _query_params.append(("pageSize", page_size))

        if name_eq is not None:

            _query_params.append(("name[eq]", name_eq))

        if name_like is not None:

            _query_params.append(("name[like]", name_like))

        if type_eq is not None:

            _query_params.append(("type[eq]", type_eq))

        if state_eq is not None:

            _query_params.append(("state[eq]", state_eq))

        if state_neq is not None:

            _query_params.append(("state[neq]", state_neq))

        if active_eq is not None:

            _query_params.append(("active[eq]", active_eq))

        if creation_started_gt is not None:

            _query_params.append(("creationStarted[gt]", creation_started_gt))

        if creation_started_lt is not None:

            _query_params.append(("creationStarted[lt]", creation_started_lt))

        if creation_started_gte is not None:

            _query_params.append(("creationStarted[gte]", creation_started_gte))

        if creation_started_lte is not None:

            _query_params.append(("creationStarted[lte]", creation_started_lte))

        if creation_finished_gt is not None:

            _query_params.append(("creationFinished[gt]", creation_finished_gt))

        if creation_finished_lt is not None:

            _query_params.append(("creationFinished[lt]", creation_finished_lt))

        if creation_finished_gte is not None:

            _query_params.append(("creationFinished[gte]", creation_finished_gte))

        if creation_finished_lte is not None:

            _query_params.append(("creationFinished[lte]", creation_finished_lte))

        if update_started_gt is not None:

            _query_params.append(("updateStarted[gt]", update_started_gt))

        if update_started_lt is not None:

            _query_params.append(("updateStarted[lt]", update_started_lt))

        if update_started_gte is not None:

            _query_params.append(("updateStarted[gte]", update_started_gte))

        if update_started_lte is not None:

            _query_params.append(("updateStarted[lte]", update_started_lte))

        if update_finished_gt is not None:

            _query_params.append(("updateFinished[gt]", update_finished_gt))

        if update_finished_lt is not None:

            _query_params.append(("updateFinished[lt]", update_finished_lt))

        if update_finished_gte is not None:

            _query_params.append(("updateFinished[gte]", update_finished_gte))

        if update_finished_lte is not None:

            _query_params.append(("updateFinished[lte]", update_finished_lte))

        if order_by_name is not None:

            _query_params.append(("orderBy[name]", order_by_name))

        if order_by_creation_started is not None:

            _query_params.append(("orderBy[creationStarted]", order_by_creation_started))

        if order_by_creation_finished is not None:

            _query_params.append(("orderBy[creationFinished]", order_by_creation_finished))

        if order_by_update_started is not None:

            _query_params.append(("orderBy[updateStarted]", order_by_update_started))

        if order_by_update_finished is not None:

            _query_params.append(("orderBy[updateFinished]", order_by_update_finished))

        if order_by_type is not None:

            _query_params.append(("orderBy[type]", order_by_type))

        if order_by_state is not None:

            _query_params.append(("orderBy[state]", order_by_state))

        if order_by_record_count is not None:

            _query_params.append(("orderBy[recordCount]", order_by_record_count))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/rrsets",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def list_zones(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="page")] = None,
        page_size: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="page size")
        ] = None,
        dns_name_eq: Annotated[Optional[StrictStr], Field(description="filter dns name equal")] = None,
        dns_name_like: Annotated[Optional[StrictStr], Field(description="filter dns name like")] = None,
        type_eq: Annotated[Optional[StrictStr], Field(description="filter type")] = None,
        name_eq: Annotated[Optional[StrictStr], Field(description="filter name equal")] = None,
        name_neq: Annotated[Optional[StrictStr], Field(description="filter name not equal")] = None,
        name_like: Annotated[Optional[StrictStr], Field(description="filter name like")] = None,
        description_eq: Annotated[Optional[StrictStr], Field(description="filter description equal")] = None,
        description_neq: Annotated[Optional[StrictStr], Field(description="filter description not equal")] = None,
        description_like: Annotated[Optional[StrictStr], Field(description="filter description like")] = None,
        state_eq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        state_neq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        primary_name_server_eq: Annotated[
            Optional[StrictStr], Field(description="filter primary name server equal")
        ] = None,
        primary_name_server_like: Annotated[
            Optional[StrictStr], Field(description="filter primary name server like")
        ] = None,
        is_reverse_zone_eq: Annotated[Optional[StrictBool], Field(description="filter reverse zone equal")] = None,
        active_eq: Annotated[Optional[StrictBool], Field(description="filter active equal")] = None,
        creation_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater with utc timestamp")
        ] = None,
        creation_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser with utc timestamp")
        ] = None,
        creation_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater equal with utc timestamp")
        ] = None,
        creation_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser equal with utc timestamp")
        ] = None,
        creation_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater with utc timestamp")
        ] = None,
        creation_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser with utc timestamp")
        ] = None,
        creation_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater equal with utc timestamp")
        ] = None,
        creation_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser equal with utc timestamp")
        ] = None,
        update_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter update started greater with utc timestamp")
        ] = None,
        update_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser with utc timestamp")
        ] = None,
        update_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter update started greater equal with utc timestamp")
        ] = None,
        update_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser equal with utc timestamp")
        ] = None,
        update_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater with utc timestamp")
        ] = None,
        update_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser with utc timestamp")
        ] = None,
        update_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater equal with utc timestamp")
        ] = None,
        update_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser equal with utc timestamp")
        ] = None,
        label_key_eq: Annotated[
            Optional[List[StrictStr]], Field(description="filter zones according to the zone label keys.")
        ] = None,
        label_value_eq: Annotated[
            Optional[List[StrictStr]], Field(description="filter zones according to the zone label values.")
        ] = None,
        order_by_dns_name: Annotated[Optional[StrictStr], Field(description="order by dns name")] = None,
        order_by_name: Annotated[Optional[StrictStr], Field(description="order by name")] = None,
        order_by_record_count: Annotated[Optional[StrictStr], Field(description="order by record count")] = None,
        order_by_type: Annotated[Optional[StrictStr], Field(description="order by type")] = None,
        order_by_description: Annotated[Optional[StrictStr], Field(description="order by description")] = None,
        order_by_creation_started: Annotated[Optional[StrictStr], Field(description="order by creationStarted")] = None,
        order_by_creation_finished: Annotated[
            Optional[StrictStr], Field(description="order by creationFinished")
        ] = None,
        order_by_update_started: Annotated[Optional[StrictStr], Field(description="order by updateStarted")] = None,
        order_by_update_finished: Annotated[Optional[StrictStr], Field(description="order by updateFinished")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListZonesResponse:
        """All get selected zones

        All zone

        :param project_id: project id (required)
        :type project_id: str
        :param page: page
        :type page: int
        :param page_size: page size
        :type page_size: int
        :param dns_name_eq: filter dns name equal
        :type dns_name_eq: str
        :param dns_name_like: filter dns name like
        :type dns_name_like: str
        :param type_eq: filter type
        :type type_eq: str
        :param name_eq: filter name equal
        :type name_eq: str
        :param name_neq: filter name not equal
        :type name_neq: str
        :param name_like: filter name like
        :type name_like: str
        :param description_eq: filter description equal
        :type description_eq: str
        :param description_neq: filter description not equal
        :type description_neq: str
        :param description_like: filter description like
        :type description_like: str
        :param state_eq: filter state
        :type state_eq: str
        :param state_neq: filter state
        :type state_neq: str
        :param primary_name_server_eq: filter primary name server equal
        :type primary_name_server_eq: str
        :param primary_name_server_like: filter primary name server like
        :type primary_name_server_like: str
        :param is_reverse_zone_eq: filter reverse zone equal
        :type is_reverse_zone_eq: bool
        :param active_eq: filter active equal
        :type active_eq: bool
        :param creation_started_gt: filter creation started greater with utc timestamp
        :type creation_started_gt: str
        :param creation_started_lt: filter creation started lesser with utc timestamp
        :type creation_started_lt: str
        :param creation_started_gte: filter creation started greater equal with utc timestamp
        :type creation_started_gte: str
        :param creation_started_lte: filter creation started lesser equal with utc timestamp
        :type creation_started_lte: str
        :param creation_finished_gt: filter creation finished greater with utc timestamp
        :type creation_finished_gt: str
        :param creation_finished_lt: filter creation finished lesser with utc timestamp
        :type creation_finished_lt: str
        :param creation_finished_gte: filter creation finished greater equal with utc timestamp
        :type creation_finished_gte: str
        :param creation_finished_lte: filter creation finished lesser equal with utc timestamp
        :type creation_finished_lte: str
        :param update_started_gt: filter update started greater with utc timestamp
        :type update_started_gt: str
        :param update_started_lt: filter update started lesser with utc timestamp
        :type update_started_lt: str
        :param update_started_gte: filter update started greater equal with utc timestamp
        :type update_started_gte: str
        :param update_started_lte: filter update started lesser equal with utc timestamp
        :type update_started_lte: str
        :param update_finished_gt: filter update finished greater with utc timestamp
        :type update_finished_gt: str
        :param update_finished_lt: filter update finished lesser with utc timestamp
        :type update_finished_lt: str
        :param update_finished_gte: filter update finished greater equal with utc timestamp
        :type update_finished_gte: str
        :param update_finished_lte: filter update finished lesser equal with utc timestamp
        :type update_finished_lte: str
        :param label_key_eq: filter zones according to the zone label keys.
        :type label_key_eq: List[str]
        :param label_value_eq: filter zones according to the zone label values.
        :type label_value_eq: List[str]
        :param order_by_dns_name: order by dns name
        :type order_by_dns_name: str
        :param order_by_name: order by name
        :type order_by_name: str
        :param order_by_record_count: order by record count
        :type order_by_record_count: str
        :param order_by_type: order by type
        :type order_by_type: str
        :param order_by_description: order by description
        :type order_by_description: str
        :param order_by_creation_started: order by creationStarted
        :type order_by_creation_started: str
        :param order_by_creation_finished: order by creationFinished
        :type order_by_creation_finished: str
        :param order_by_update_started: order by updateStarted
        :type order_by_update_started: str
        :param order_by_update_finished: order by updateFinished
        :type order_by_update_finished: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._list_zones_serialize(
            project_id=project_id,
            page=page,
            page_size=page_size,
            dns_name_eq=dns_name_eq,
            dns_name_like=dns_name_like,
            type_eq=type_eq,
            name_eq=name_eq,
            name_neq=name_neq,
            name_like=name_like,
            description_eq=description_eq,
            description_neq=description_neq,
            description_like=description_like,
            state_eq=state_eq,
            state_neq=state_neq,
            primary_name_server_eq=primary_name_server_eq,
            primary_name_server_like=primary_name_server_like,
            is_reverse_zone_eq=is_reverse_zone_eq,
            active_eq=active_eq,
            creation_started_gt=creation_started_gt,
            creation_started_lt=creation_started_lt,
            creation_started_gte=creation_started_gte,
            creation_started_lte=creation_started_lte,
            creation_finished_gt=creation_finished_gt,
            creation_finished_lt=creation_finished_lt,
            creation_finished_gte=creation_finished_gte,
            creation_finished_lte=creation_finished_lte,
            update_started_gt=update_started_gt,
            update_started_lt=update_started_lt,
            update_started_gte=update_started_gte,
            update_started_lte=update_started_lte,
            update_finished_gt=update_finished_gt,
            update_finished_lt=update_finished_lt,
            update_finished_gte=update_finished_gte,
            update_finished_lte=update_finished_lte,
            label_key_eq=label_key_eq,
            label_value_eq=label_value_eq,
            order_by_dns_name=order_by_dns_name,
            order_by_name=order_by_name,
            order_by_record_count=order_by_record_count,
            order_by_type=order_by_type,
            order_by_description=order_by_description,
            order_by_creation_started=order_by_creation_started,
            order_by_creation_finished=order_by_creation_finished,
            order_by_update_started=order_by_update_started,
            order_by_update_finished=order_by_update_finished,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListZonesResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def list_zones_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="page")] = None,
        page_size: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="page size")
        ] = None,
        dns_name_eq: Annotated[Optional[StrictStr], Field(description="filter dns name equal")] = None,
        dns_name_like: Annotated[Optional[StrictStr], Field(description="filter dns name like")] = None,
        type_eq: Annotated[Optional[StrictStr], Field(description="filter type")] = None,
        name_eq: Annotated[Optional[StrictStr], Field(description="filter name equal")] = None,
        name_neq: Annotated[Optional[StrictStr], Field(description="filter name not equal")] = None,
        name_like: Annotated[Optional[StrictStr], Field(description="filter name like")] = None,
        description_eq: Annotated[Optional[StrictStr], Field(description="filter description equal")] = None,
        description_neq: Annotated[Optional[StrictStr], Field(description="filter description not equal")] = None,
        description_like: Annotated[Optional[StrictStr], Field(description="filter description like")] = None,
        state_eq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        state_neq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        primary_name_server_eq: Annotated[
            Optional[StrictStr], Field(description="filter primary name server equal")
        ] = None,
        primary_name_server_like: Annotated[
            Optional[StrictStr], Field(description="filter primary name server like")
        ] = None,
        is_reverse_zone_eq: Annotated[Optional[StrictBool], Field(description="filter reverse zone equal")] = None,
        active_eq: Annotated[Optional[StrictBool], Field(description="filter active equal")] = None,
        creation_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater with utc timestamp")
        ] = None,
        creation_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser with utc timestamp")
        ] = None,
        creation_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater equal with utc timestamp")
        ] = None,
        creation_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser equal with utc timestamp")
        ] = None,
        creation_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater with utc timestamp")
        ] = None,
        creation_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser with utc timestamp")
        ] = None,
        creation_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater equal with utc timestamp")
        ] = None,
        creation_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser equal with utc timestamp")
        ] = None,
        update_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter update started greater with utc timestamp")
        ] = None,
        update_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser with utc timestamp")
        ] = None,
        update_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter update started greater equal with utc timestamp")
        ] = None,
        update_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser equal with utc timestamp")
        ] = None,
        update_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater with utc timestamp")
        ] = None,
        update_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser with utc timestamp")
        ] = None,
        update_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater equal with utc timestamp")
        ] = None,
        update_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser equal with utc timestamp")
        ] = None,
        label_key_eq: Annotated[
            Optional[List[StrictStr]], Field(description="filter zones according to the zone label keys.")
        ] = None,
        label_value_eq: Annotated[
            Optional[List[StrictStr]], Field(description="filter zones according to the zone label values.")
        ] = None,
        order_by_dns_name: Annotated[Optional[StrictStr], Field(description="order by dns name")] = None,
        order_by_name: Annotated[Optional[StrictStr], Field(description="order by name")] = None,
        order_by_record_count: Annotated[Optional[StrictStr], Field(description="order by record count")] = None,
        order_by_type: Annotated[Optional[StrictStr], Field(description="order by type")] = None,
        order_by_description: Annotated[Optional[StrictStr], Field(description="order by description")] = None,
        order_by_creation_started: Annotated[Optional[StrictStr], Field(description="order by creationStarted")] = None,
        order_by_creation_finished: Annotated[
            Optional[StrictStr], Field(description="order by creationFinished")
        ] = None,
        order_by_update_started: Annotated[Optional[StrictStr], Field(description="order by updateStarted")] = None,
        order_by_update_finished: Annotated[Optional[StrictStr], Field(description="order by updateFinished")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListZonesResponse]:
        """All get selected zones

        All zone

        :param project_id: project id (required)
        :type project_id: str
        :param page: page
        :type page: int
        :param page_size: page size
        :type page_size: int
        :param dns_name_eq: filter dns name equal
        :type dns_name_eq: str
        :param dns_name_like: filter dns name like
        :type dns_name_like: str
        :param type_eq: filter type
        :type type_eq: str
        :param name_eq: filter name equal
        :type name_eq: str
        :param name_neq: filter name not equal
        :type name_neq: str
        :param name_like: filter name like
        :type name_like: str
        :param description_eq: filter description equal
        :type description_eq: str
        :param description_neq: filter description not equal
        :type description_neq: str
        :param description_like: filter description like
        :type description_like: str
        :param state_eq: filter state
        :type state_eq: str
        :param state_neq: filter state
        :type state_neq: str
        :param primary_name_server_eq: filter primary name server equal
        :type primary_name_server_eq: str
        :param primary_name_server_like: filter primary name server like
        :type primary_name_server_like: str
        :param is_reverse_zone_eq: filter reverse zone equal
        :type is_reverse_zone_eq: bool
        :param active_eq: filter active equal
        :type active_eq: bool
        :param creation_started_gt: filter creation started greater with utc timestamp
        :type creation_started_gt: str
        :param creation_started_lt: filter creation started lesser with utc timestamp
        :type creation_started_lt: str
        :param creation_started_gte: filter creation started greater equal with utc timestamp
        :type creation_started_gte: str
        :param creation_started_lte: filter creation started lesser equal with utc timestamp
        :type creation_started_lte: str
        :param creation_finished_gt: filter creation finished greater with utc timestamp
        :type creation_finished_gt: str
        :param creation_finished_lt: filter creation finished lesser with utc timestamp
        :type creation_finished_lt: str
        :param creation_finished_gte: filter creation finished greater equal with utc timestamp
        :type creation_finished_gte: str
        :param creation_finished_lte: filter creation finished lesser equal with utc timestamp
        :type creation_finished_lte: str
        :param update_started_gt: filter update started greater with utc timestamp
        :type update_started_gt: str
        :param update_started_lt: filter update started lesser with utc timestamp
        :type update_started_lt: str
        :param update_started_gte: filter update started greater equal with utc timestamp
        :type update_started_gte: str
        :param update_started_lte: filter update started lesser equal with utc timestamp
        :type update_started_lte: str
        :param update_finished_gt: filter update finished greater with utc timestamp
        :type update_finished_gt: str
        :param update_finished_lt: filter update finished lesser with utc timestamp
        :type update_finished_lt: str
        :param update_finished_gte: filter update finished greater equal with utc timestamp
        :type update_finished_gte: str
        :param update_finished_lte: filter update finished lesser equal with utc timestamp
        :type update_finished_lte: str
        :param label_key_eq: filter zones according to the zone label keys.
        :type label_key_eq: List[str]
        :param label_value_eq: filter zones according to the zone label values.
        :type label_value_eq: List[str]
        :param order_by_dns_name: order by dns name
        :type order_by_dns_name: str
        :param order_by_name: order by name
        :type order_by_name: str
        :param order_by_record_count: order by record count
        :type order_by_record_count: str
        :param order_by_type: order by type
        :type order_by_type: str
        :param order_by_description: order by description
        :type order_by_description: str
        :param order_by_creation_started: order by creationStarted
        :type order_by_creation_started: str
        :param order_by_creation_finished: order by creationFinished
        :type order_by_creation_finished: str
        :param order_by_update_started: order by updateStarted
        :type order_by_update_started: str
        :param order_by_update_finished: order by updateFinished
        :type order_by_update_finished: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._list_zones_serialize(
            project_id=project_id,
            page=page,
            page_size=page_size,
            dns_name_eq=dns_name_eq,
            dns_name_like=dns_name_like,
            type_eq=type_eq,
            name_eq=name_eq,
            name_neq=name_neq,
            name_like=name_like,
            description_eq=description_eq,
            description_neq=description_neq,
            description_like=description_like,
            state_eq=state_eq,
            state_neq=state_neq,
            primary_name_server_eq=primary_name_server_eq,
            primary_name_server_like=primary_name_server_like,
            is_reverse_zone_eq=is_reverse_zone_eq,
            active_eq=active_eq,
            creation_started_gt=creation_started_gt,
            creation_started_lt=creation_started_lt,
            creation_started_gte=creation_started_gte,
            creation_started_lte=creation_started_lte,
            creation_finished_gt=creation_finished_gt,
            creation_finished_lt=creation_finished_lt,
            creation_finished_gte=creation_finished_gte,
            creation_finished_lte=creation_finished_lte,
            update_started_gt=update_started_gt,
            update_started_lt=update_started_lt,
            update_started_gte=update_started_gte,
            update_started_lte=update_started_lte,
            update_finished_gt=update_finished_gt,
            update_finished_lt=update_finished_lt,
            update_finished_gte=update_finished_gte,
            update_finished_lte=update_finished_lte,
            label_key_eq=label_key_eq,
            label_value_eq=label_value_eq,
            order_by_dns_name=order_by_dns_name,
            order_by_name=order_by_name,
            order_by_record_count=order_by_record_count,
            order_by_type=order_by_type,
            order_by_description=order_by_description,
            order_by_creation_started=order_by_creation_started,
            order_by_creation_finished=order_by_creation_finished,
            order_by_update_started=order_by_update_started,
            order_by_update_finished=order_by_update_finished,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListZonesResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def list_zones_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        page: Annotated[Optional[Annotated[int, Field(strict=True, ge=1)]], Field(description="page")] = None,
        page_size: Annotated[
            Optional[Annotated[int, Field(le=10000, strict=True, ge=1)]], Field(description="page size")
        ] = None,
        dns_name_eq: Annotated[Optional[StrictStr], Field(description="filter dns name equal")] = None,
        dns_name_like: Annotated[Optional[StrictStr], Field(description="filter dns name like")] = None,
        type_eq: Annotated[Optional[StrictStr], Field(description="filter type")] = None,
        name_eq: Annotated[Optional[StrictStr], Field(description="filter name equal")] = None,
        name_neq: Annotated[Optional[StrictStr], Field(description="filter name not equal")] = None,
        name_like: Annotated[Optional[StrictStr], Field(description="filter name like")] = None,
        description_eq: Annotated[Optional[StrictStr], Field(description="filter description equal")] = None,
        description_neq: Annotated[Optional[StrictStr], Field(description="filter description not equal")] = None,
        description_like: Annotated[Optional[StrictStr], Field(description="filter description like")] = None,
        state_eq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        state_neq: Annotated[Optional[StrictStr], Field(description="filter state")] = None,
        primary_name_server_eq: Annotated[
            Optional[StrictStr], Field(description="filter primary name server equal")
        ] = None,
        primary_name_server_like: Annotated[
            Optional[StrictStr], Field(description="filter primary name server like")
        ] = None,
        is_reverse_zone_eq: Annotated[Optional[StrictBool], Field(description="filter reverse zone equal")] = None,
        active_eq: Annotated[Optional[StrictBool], Field(description="filter active equal")] = None,
        creation_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater with utc timestamp")
        ] = None,
        creation_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser with utc timestamp")
        ] = None,
        creation_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation started greater equal with utc timestamp")
        ] = None,
        creation_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation started lesser equal with utc timestamp")
        ] = None,
        creation_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater with utc timestamp")
        ] = None,
        creation_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser with utc timestamp")
        ] = None,
        creation_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished greater equal with utc timestamp")
        ] = None,
        creation_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter creation finished lesser equal with utc timestamp")
        ] = None,
        update_started_gt: Annotated[
            Optional[StrictStr], Field(description="filter update started greater with utc timestamp")
        ] = None,
        update_started_lt: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser with utc timestamp")
        ] = None,
        update_started_gte: Annotated[
            Optional[StrictStr], Field(description="filter update started greater equal with utc timestamp")
        ] = None,
        update_started_lte: Annotated[
            Optional[StrictStr], Field(description="filter update started lesser equal with utc timestamp")
        ] = None,
        update_finished_gt: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater with utc timestamp")
        ] = None,
        update_finished_lt: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser with utc timestamp")
        ] = None,
        update_finished_gte: Annotated[
            Optional[StrictStr], Field(description="filter update finished greater equal with utc timestamp")
        ] = None,
        update_finished_lte: Annotated[
            Optional[StrictStr], Field(description="filter update finished lesser equal with utc timestamp")
        ] = None,
        label_key_eq: Annotated[
            Optional[List[StrictStr]], Field(description="filter zones according to the zone label keys.")
        ] = None,
        label_value_eq: Annotated[
            Optional[List[StrictStr]], Field(description="filter zones according to the zone label values.")
        ] = None,
        order_by_dns_name: Annotated[Optional[StrictStr], Field(description="order by dns name")] = None,
        order_by_name: Annotated[Optional[StrictStr], Field(description="order by name")] = None,
        order_by_record_count: Annotated[Optional[StrictStr], Field(description="order by record count")] = None,
        order_by_type: Annotated[Optional[StrictStr], Field(description="order by type")] = None,
        order_by_description: Annotated[Optional[StrictStr], Field(description="order by description")] = None,
        order_by_creation_started: Annotated[Optional[StrictStr], Field(description="order by creationStarted")] = None,
        order_by_creation_finished: Annotated[
            Optional[StrictStr], Field(description="order by creationFinished")
        ] = None,
        order_by_update_started: Annotated[Optional[StrictStr], Field(description="order by updateStarted")] = None,
        order_by_update_finished: Annotated[Optional[StrictStr], Field(description="order by updateFinished")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """All get selected zones

        All zone

        :param project_id: project id (required)
        :type project_id: str
        :param page: page
        :type page: int
        :param page_size: page size
        :type page_size: int
        :param dns_name_eq: filter dns name equal
        :type dns_name_eq: str
        :param dns_name_like: filter dns name like
        :type dns_name_like: str
        :param type_eq: filter type
        :type type_eq: str
        :param name_eq: filter name equal
        :type name_eq: str
        :param name_neq: filter name not equal
        :type name_neq: str
        :param name_like: filter name like
        :type name_like: str
        :param description_eq: filter description equal
        :type description_eq: str
        :param description_neq: filter description not equal
        :type description_neq: str
        :param description_like: filter description like
        :type description_like: str
        :param state_eq: filter state
        :type state_eq: str
        :param state_neq: filter state
        :type state_neq: str
        :param primary_name_server_eq: filter primary name server equal
        :type primary_name_server_eq: str
        :param primary_name_server_like: filter primary name server like
        :type primary_name_server_like: str
        :param is_reverse_zone_eq: filter reverse zone equal
        :type is_reverse_zone_eq: bool
        :param active_eq: filter active equal
        :type active_eq: bool
        :param creation_started_gt: filter creation started greater with utc timestamp
        :type creation_started_gt: str
        :param creation_started_lt: filter creation started lesser with utc timestamp
        :type creation_started_lt: str
        :param creation_started_gte: filter creation started greater equal with utc timestamp
        :type creation_started_gte: str
        :param creation_started_lte: filter creation started lesser equal with utc timestamp
        :type creation_started_lte: str
        :param creation_finished_gt: filter creation finished greater with utc timestamp
        :type creation_finished_gt: str
        :param creation_finished_lt: filter creation finished lesser with utc timestamp
        :type creation_finished_lt: str
        :param creation_finished_gte: filter creation finished greater equal with utc timestamp
        :type creation_finished_gte: str
        :param creation_finished_lte: filter creation finished lesser equal with utc timestamp
        :type creation_finished_lte: str
        :param update_started_gt: filter update started greater with utc timestamp
        :type update_started_gt: str
        :param update_started_lt: filter update started lesser with utc timestamp
        :type update_started_lt: str
        :param update_started_gte: filter update started greater equal with utc timestamp
        :type update_started_gte: str
        :param update_started_lte: filter update started lesser equal with utc timestamp
        :type update_started_lte: str
        :param update_finished_gt: filter update finished greater with utc timestamp
        :type update_finished_gt: str
        :param update_finished_lt: filter update finished lesser with utc timestamp
        :type update_finished_lt: str
        :param update_finished_gte: filter update finished greater equal with utc timestamp
        :type update_finished_gte: str
        :param update_finished_lte: filter update finished lesser equal with utc timestamp
        :type update_finished_lte: str
        :param label_key_eq: filter zones according to the zone label keys.
        :type label_key_eq: List[str]
        :param label_value_eq: filter zones according to the zone label values.
        :type label_value_eq: List[str]
        :param order_by_dns_name: order by dns name
        :type order_by_dns_name: str
        :param order_by_name: order by name
        :type order_by_name: str
        :param order_by_record_count: order by record count
        :type order_by_record_count: str
        :param order_by_type: order by type
        :type order_by_type: str
        :param order_by_description: order by description
        :type order_by_description: str
        :param order_by_creation_started: order by creationStarted
        :type order_by_creation_started: str
        :param order_by_creation_finished: order by creationFinished
        :type order_by_creation_finished: str
        :param order_by_update_started: order by updateStarted
        :type order_by_update_started: str
        :param order_by_update_finished: order by updateFinished
        :type order_by_update_finished: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._list_zones_serialize(
            project_id=project_id,
            page=page,
            page_size=page_size,
            dns_name_eq=dns_name_eq,
            dns_name_like=dns_name_like,
            type_eq=type_eq,
            name_eq=name_eq,
            name_neq=name_neq,
            name_like=name_like,
            description_eq=description_eq,
            description_neq=description_neq,
            description_like=description_like,
            state_eq=state_eq,
            state_neq=state_neq,
            primary_name_server_eq=primary_name_server_eq,
            primary_name_server_like=primary_name_server_like,
            is_reverse_zone_eq=is_reverse_zone_eq,
            active_eq=active_eq,
            creation_started_gt=creation_started_gt,
            creation_started_lt=creation_started_lt,
            creation_started_gte=creation_started_gte,
            creation_started_lte=creation_started_lte,
            creation_finished_gt=creation_finished_gt,
            creation_finished_lt=creation_finished_lt,
            creation_finished_gte=creation_finished_gte,
            creation_finished_lte=creation_finished_lte,
            update_started_gt=update_started_gt,
            update_started_lt=update_started_lt,
            update_started_gte=update_started_gte,
            update_started_lte=update_started_lte,
            update_finished_gt=update_finished_gt,
            update_finished_lt=update_finished_lt,
            update_finished_gte=update_finished_gte,
            update_finished_lte=update_finished_lte,
            label_key_eq=label_key_eq,
            label_value_eq=label_value_eq,
            order_by_dns_name=order_by_dns_name,
            order_by_name=order_by_name,
            order_by_record_count=order_by_record_count,
            order_by_type=order_by_type,
            order_by_description=order_by_description,
            order_by_creation_started=order_by_creation_started,
            order_by_creation_finished=order_by_creation_finished,
            order_by_update_started=order_by_update_started,
            order_by_update_finished=order_by_update_finished,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "ListZonesResponse",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _list_zones_serialize(
        self,
        project_id,
        page,
        page_size,
        dns_name_eq,
        dns_name_like,
        type_eq,
        name_eq,
        name_neq,
        name_like,
        description_eq,
        description_neq,
        description_like,
        state_eq,
        state_neq,
        primary_name_server_eq,
        primary_name_server_like,
        is_reverse_zone_eq,
        active_eq,
        creation_started_gt,
        creation_started_lt,
        creation_started_gte,
        creation_started_lte,
        creation_finished_gt,
        creation_finished_lt,
        creation_finished_gte,
        creation_finished_lte,
        update_started_gt,
        update_started_lt,
        update_started_gte,
        update_started_lte,
        update_finished_gt,
        update_finished_lt,
        update_finished_gte,
        update_finished_lte,
        label_key_eq,
        label_value_eq,
        order_by_dns_name,
        order_by_name,
        order_by_record_count,
        order_by_type,
        order_by_description,
        order_by_creation_started,
        order_by_creation_finished,
        order_by_update_started,
        order_by_update_finished,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            "labelKey[eq]": "csv",
            "labelValue[eq]": "csv",
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        # process the query parameters
        if page is not None:

            _query_params.append(("page", page))

        if page_size is not None:

            _query_params.append(("pageSize", page_size))

        if dns_name_eq is not None:

            _query_params.append(("dnsName[eq]", dns_name_eq))

        if dns_name_like is not None:

            _query_params.append(("dnsName[like]", dns_name_like))

        if type_eq is not None:

            _query_params.append(("type[eq]", type_eq))

        if name_eq is not None:

            _query_params.append(("name[eq]", name_eq))

        if name_neq is not None:

            _query_params.append(("name[neq]", name_neq))

        if name_like is not None:

            _query_params.append(("name[like]", name_like))

        if description_eq is not None:

            _query_params.append(("description[eq]", description_eq))

        if description_neq is not None:

            _query_params.append(("description[neq]", description_neq))

        if description_like is not None:

            _query_params.append(("description[like]", description_like))

        if state_eq is not None:

            _query_params.append(("state[eq]", state_eq))

        if state_neq is not None:

            _query_params.append(("state[neq]", state_neq))

        if primary_name_server_eq is not None:

            _query_params.append(("primaryNameServer[eq]", primary_name_server_eq))

        if primary_name_server_like is not None:

            _query_params.append(("primaryNameServer[like]", primary_name_server_like))

        if is_reverse_zone_eq is not None:

            _query_params.append(("isReverseZone[eq]", is_reverse_zone_eq))

        if active_eq is not None:

            _query_params.append(("active[eq]", active_eq))

        if creation_started_gt is not None:

            _query_params.append(("creationStarted[gt]", creation_started_gt))

        if creation_started_lt is not None:

            _query_params.append(("creationStarted[lt]", creation_started_lt))

        if creation_started_gte is not None:

            _query_params.append(("creationStarted[gte]", creation_started_gte))

        if creation_started_lte is not None:

            _query_params.append(("creationStarted[lte]", creation_started_lte))

        if creation_finished_gt is not None:

            _query_params.append(("creationFinished[gt]", creation_finished_gt))

        if creation_finished_lt is not None:

            _query_params.append(("creationFinished[lt]", creation_finished_lt))

        if creation_finished_gte is not None:

            _query_params.append(("creationFinished[gte]", creation_finished_gte))

        if creation_finished_lte is not None:

            _query_params.append(("creationFinished[lte]", creation_finished_lte))

        if update_started_gt is not None:

            _query_params.append(("updateStarted[gt]", update_started_gt))

        if update_started_lt is not None:

            _query_params.append(("updateStarted[lt]", update_started_lt))

        if update_started_gte is not None:

            _query_params.append(("updateStarted[gte]", update_started_gte))

        if update_started_lte is not None:

            _query_params.append(("updateStarted[lte]", update_started_lte))

        if update_finished_gt is not None:

            _query_params.append(("updateFinished[gt]", update_finished_gt))

        if update_finished_lt is not None:

            _query_params.append(("updateFinished[lt]", update_finished_lt))

        if update_finished_gte is not None:

            _query_params.append(("updateFinished[gte]", update_finished_gte))

        if update_finished_lte is not None:

            _query_params.append(("updateFinished[lte]", update_finished_lte))

        if label_key_eq is not None:

            _query_params.append(("labelKey[eq]", label_key_eq))

        if label_value_eq is not None:

            _query_params.append(("labelValue[eq]", label_value_eq))

        if order_by_dns_name is not None:

            _query_params.append(("orderBy[dnsName]", order_by_dns_name))

        if order_by_name is not None:

            _query_params.append(("orderBy[name]", order_by_name))

        if order_by_record_count is not None:

            _query_params.append(("orderBy[recordCount]", order_by_record_count))

        if order_by_type is not None:

            _query_params.append(("orderBy[type]", order_by_type))

        if order_by_description is not None:

            _query_params.append(("orderBy[description]", order_by_description))

        if order_by_creation_started is not None:

            _query_params.append(("orderBy[creationStarted]", order_by_creation_started))

        if order_by_creation_finished is not None:

            _query_params.append(("orderBy[creationFinished]", order_by_creation_finished))

        if order_by_update_started is not None:

            _query_params.append(("orderBy[updateStarted]", order_by_update_started))

        if order_by_update_finished is not None:

            _query_params.append(("orderBy[updateFinished]", order_by_update_finished))

        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/v1/projects/{projectId}/zones",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def move_zone(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        move_zone_payload: Annotated[MoveZonePayload, Field(description="information about the move")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """move zone from one project to another

        move zone from one project to another

        :param project_id: project id (required)
        :type project_id: str
        :param move_zone_payload: information about the move (required)
        :type move_zone_payload: MoveZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._move_zone_serialize(
            project_id=project_id,
            move_zone_payload=move_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Message",
            "400": "ErrorMessage",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def move_zone_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        move_zone_payload: Annotated[MoveZonePayload, Field(description="information about the move")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """move zone from one project to another

        move zone from one project to another

        :param project_id: project id (required)
        :type project_id: str
        :param move_zone_payload: information about the move (required)
        :type move_zone_payload: MoveZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._move_zone_serialize(
            project_id=project_id,
            move_zone_payload=move_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Message",
            "400": "ErrorMessage",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def move_zone_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        move_zone_payload: Annotated[MoveZonePayload, Field(description="information about the move")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """move zone from one project to another

        move zone from one project to another

        :param project_id: project id (required)
        :type project_id: str
        :param move_zone_payload: information about the move (required)
        :type move_zone_payload: MoveZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._move_zone_serialize(
            project_id=project_id,
            move_zone_payload=move_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Message",
            "400": "ErrorMessage",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _move_zone_serialize(
        self,
        project_id,
        move_zone_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if move_zone_payload is not None:
            _body_params = move_zone_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/move-zone",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def partial_update_record(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        partial_update_record_payload: Annotated[PartialUpdateRecordPayload, Field(description="rrset to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """PatchRecords updates a record in a rrset

        PatchRecords rrset updates a record in a rrset

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param partial_update_record_payload: rrset to update (required)
        :type partial_update_record_payload: PartialUpdateRecordPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._partial_update_record_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            partial_update_record_payload=partial_update_record_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def partial_update_record_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        partial_update_record_payload: Annotated[PartialUpdateRecordPayload, Field(description="rrset to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """PatchRecords updates a record in a rrset

        PatchRecords rrset updates a record in a rrset

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param partial_update_record_payload: rrset to update (required)
        :type partial_update_record_payload: PartialUpdateRecordPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._partial_update_record_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            partial_update_record_payload=partial_update_record_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def partial_update_record_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        partial_update_record_payload: Annotated[PartialUpdateRecordPayload, Field(description="rrset to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """PatchRecords updates a record in a rrset

        PatchRecords rrset updates a record in a rrset

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param partial_update_record_payload: rrset to update (required)
        :type partial_update_record_payload: PartialUpdateRecordPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._partial_update_record_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            partial_update_record_payload=partial_update_record_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _partial_update_record_serialize(
        self,
        project_id,
        zone_id,
        rr_set_id,
        partial_update_record_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        if rr_set_id is not None:
            _path_params["rrSetId"] = rr_set_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if partial_update_record_payload is not None:
            _body_params = partial_update_record_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}/records",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def partial_update_record_set(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        partial_update_record_set_payload: Annotated[
            PartialUpdateRecordSetPayload, Field(description="record set to patch")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Patch updates a record set

        Patch record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param partial_update_record_set_payload: record set to patch (required)
        :type partial_update_record_set_payload: PartialUpdateRecordSetPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._partial_update_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            partial_update_record_set_payload=partial_update_record_set_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def partial_update_record_set_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        partial_update_record_set_payload: Annotated[
            PartialUpdateRecordSetPayload, Field(description="record set to patch")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Patch updates a record set

        Patch record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param partial_update_record_set_payload: record set to patch (required)
        :type partial_update_record_set_payload: PartialUpdateRecordSetPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._partial_update_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            partial_update_record_set_payload=partial_update_record_set_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def partial_update_record_set_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        partial_update_record_set_payload: Annotated[
            PartialUpdateRecordSetPayload, Field(description="record set to patch")
        ],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Patch updates a record set

        Patch record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param partial_update_record_set_payload: record set to patch (required)
        :type partial_update_record_set_payload: PartialUpdateRecordSetPayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._partial_update_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            partial_update_record_set_payload=partial_update_record_set_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _partial_update_record_set_serialize(
        self,
        project_id,
        zone_id,
        rr_set_id,
        partial_update_record_set_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        if rr_set_id is not None:
            _path_params["rrSetId"] = rr_set_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if partial_update_record_set_payload is not None:
            _body_params = partial_update_record_set_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def partial_update_zone(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        partial_update_zone_payload: Annotated[PartialUpdateZonePayload, Field(description="zone to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ZoneResponse:
        """Patch update an existing zone

        Patch update an existing zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param partial_update_zone_payload: zone to update (required)
        :type partial_update_zone_payload: PartialUpdateZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._partial_update_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            partial_update_zone_payload=partial_update_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ZoneResponse",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def partial_update_zone_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        partial_update_zone_payload: Annotated[PartialUpdateZonePayload, Field(description="zone to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ZoneResponse]:
        """Patch update an existing zone

        Patch update an existing zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param partial_update_zone_payload: zone to update (required)
        :type partial_update_zone_payload: PartialUpdateZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._partial_update_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            partial_update_zone_payload=partial_update_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ZoneResponse",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def partial_update_zone_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        partial_update_zone_payload: Annotated[PartialUpdateZonePayload, Field(description="zone to update")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Patch update an existing zone

        Patch update an existing zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param partial_update_zone_payload: zone to update (required)
        :type partial_update_zone_payload: PartialUpdateZonePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._partial_update_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            partial_update_zone_payload=partial_update_zone_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "ZoneResponse",
            "400": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _partial_update_zone_serialize(
        self,
        project_id,
        zone_id,
        partial_update_zone_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if partial_update_zone_payload is not None:
            _body_params = partial_update_zone_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="PATCH",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def restore_record_set(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Restore record set

        Restore record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._restore_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def restore_record_set_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Restore record set

        Restore record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._restore_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def restore_record_set_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        rr_set_id: Annotated[StrictStr, Field(description="record set id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Restore record set

        Restore record set

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param rr_set_id: record set id (required)
        :type rr_set_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._restore_record_set_serialize(
            project_id=project_id,
            zone_id=zone_id,
            rr_set_id=rr_set_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "404": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _restore_record_set_serialize(
        self,
        project_id,
        zone_id,
        rr_set_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        if rr_set_id is not None:
            _path_params["rrSetId"] = rr_set_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/rrsets/{rrSetId}/restores",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def restore_zone(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Restore  an inactive zone

        Restore  an inactive zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._restore_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def restore_zone_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Restore  an inactive zone

        Restore  an inactive zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._restore_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def restore_zone_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Restore  an inactive zone

        Restore  an inactive zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._restore_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _restore_zone_serialize(
        self,
        project_id,
        zone_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/restores",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def retrieve_zone(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """Queue secondary zone for a zone transfer request.

        The zone transfer will usually be performed within a few seconds, and will be tried only once by randomly choosing one of the configured primary name servers. If that single attempt fails, no further attempt will be performed. The zone will be transferred to our inbound name server regardless of its serial, but the internal zone distribution is only reliable if the zone's serial on the customer's primary name server is higher than on the STACKIT name server. <br>NOTE: As said above, this endpoint is not a reliable way to decrease a zone's serial. To guarantee consistent zones over all STACKIT location, the zone's serial MUST always be increased on zone changes.

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._retrieve_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def retrieve_zone_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """Queue secondary zone for a zone transfer request.

        The zone transfer will usually be performed within a few seconds, and will be tried only once by randomly choosing one of the configured primary name servers. If that single attempt fails, no further attempt will be performed. The zone will be transferred to our inbound name server regardless of its serial, but the internal zone distribution is only reliable if the zone's serial on the customer's primary name server is higher than on the STACKIT name server. <br>NOTE: As said above, this endpoint is not a reliable way to decrease a zone's serial. To guarantee consistent zones over all STACKIT location, the zone's serial MUST always be increased on zone changes.

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._retrieve_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def retrieve_zone_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Queue secondary zone for a zone transfer request.

        The zone transfer will usually be performed within a few seconds, and will be tried only once by randomly choosing one of the configured primary name servers. If that single attempt fails, no further attempt will be performed. The zone will be transferred to our inbound name server regardless of its serial, but the internal zone distribution is only reliable if the zone's serial on the customer's primary name server is higher than on the STACKIT name server. <br>NOTE: As said above, this endpoint is not a reliable way to decrease a zone's serial. To guarantee consistent zones over all STACKIT location, the zone's serial MUST always be increased on zone changes.

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._retrieve_zone_serialize(
            project_id=project_id,
            zone_id=zone_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "202": "Message",
            "400": "Message",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _retrieve_zone_serialize(
        self,
        project_id,
        zone_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/retrieve",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )

    @validate_call
    def validate_move_code(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        validate_move_code_payload: Annotated[ValidateMoveCodePayload, Field(description="information about the move")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Message:
        """validate the move code is still valid for the zone

        validate the move code is still valid for the zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param validate_move_code_payload: information about the move (required)
        :type validate_move_code_payload: ValidateMoveCodePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._validate_move_code_serialize(
            project_id=project_id,
            zone_id=zone_id,
            validate_move_code_payload=validate_move_code_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Message",
            "400": "ErrorMessage",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data

    @validate_call
    def validate_move_code_with_http_info(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        validate_move_code_payload: Annotated[ValidateMoveCodePayload, Field(description="information about the move")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Message]:
        """validate the move code is still valid for the zone

        validate the move code is still valid for the zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param validate_move_code_payload: information about the move (required)
        :type validate_move_code_payload: ValidateMoveCodePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._validate_move_code_serialize(
            project_id=project_id,
            zone_id=zone_id,
            validate_move_code_payload=validate_move_code_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Message",
            "400": "ErrorMessage",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )

    @validate_call
    def validate_move_code_without_preload_content(
        self,
        project_id: Annotated[StrictStr, Field(description="project id")],
        zone_id: Annotated[StrictStr, Field(description="zone id")],
        validate_move_code_payload: Annotated[ValidateMoveCodePayload, Field(description="information about the move")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]],
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """validate the move code is still valid for the zone

        validate the move code is still valid for the zone

        :param project_id: project id (required)
        :type project_id: str
        :param zone_id: zone id (required)
        :type zone_id: str
        :param validate_move_code_payload: information about the move (required)
        :type validate_move_code_payload: ValidateMoveCodePayload
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """  # noqa: E501 docstring might be too long

        _param = self._validate_move_code_serialize(
            project_id=project_id,
            zone_id=zone_id,
            validate_move_code_payload=validate_move_code_payload,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index,
        )

        _response_types_map: Dict[str, Optional[str]] = {
            "200": "Message",
            "400": "ErrorMessage",
            "502": "Message",
        }
        response_data = self.api_client.call_api(*_param, _request_timeout=_request_timeout)
        return response_data.response

    def _validate_move_code_serialize(
        self,
        project_id,
        zone_id,
        validate_move_code_payload,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {}

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if project_id is not None:
            _path_params["projectId"] = project_id
        if zone_id is not None:
            _path_params["zoneId"] = zone_id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if validate_move_code_payload is not None:
            _body_params = validate_move_code_payload

        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params["Content-Type"] = _content_type
        else:
            _default_content_type = self.api_client.select_header_content_type(["application/json"])
            if _default_content_type is not None:
                _header_params["Content-Type"] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = []

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/v1/projects/{projectId}/zones/{zoneId}/move-code-validation",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth,
        )
